"""Python-first skill specification models for the PMD agent.

The old YAML DSL is still available for backwards compatibility, but new skills
are authored as constrained Python objects that are intended to be generated by
structured LM output.  The schema is deliberately small so that we can produce
JSON (or Python) objects via grammar-guided decoding, resulting in far less
syntax drift compared to handwritten code.

Each primitive maps 1:1 to an environment capability (button press, semantic
state refresh, checkpointing, etc.).  Higher-level constructs compose these
primitives via simple control blocks (loops, conditionals, guarded execution).
"""

from __future__ import annotations

from enum import Enum
from typing import List, Optional, Union, Literal, Dict, Any

from pydantic import BaseModel, Field, validator


# ---------------------------------------------------------------------------
# Primitives
# ---------------------------------------------------------------------------


class Button(str, Enum):
    """Available GBA button presses supported by the harness."""

    A = "A"
    B = "B"
    L = "L"
    R = "R"
    START = "START"
    SELECT = "SELECT"
    UP = "UP"
    DOWN = "DOWN"
    LEFT = "LEFT"
    RIGHT = "RIGHT"
    A_B = "A+B"  # combined wait turn helper


class PrimitiveBase(BaseModel):
    """Base class for all primitives."""

    primitive: str

    class Config:
        extra = "forbid"
        allow_mutation = False
        validate_assignment = True


class TapPrimitive(PrimitiveBase):
    """Single frame button press."""

    primitive: Literal["tap"] = "tap"
    button: Button
    repeat: int = Field(default=1, ge=1, le=10, description="Times to tap")


class HoldPrimitive(PrimitiveBase):
    """Hold a button for a fixed number of frames."""

    primitive: Literal["hold"] = "hold"
    button: Button
    frames: int = Field(default=5, ge=1, le=60)


class ReleasePrimitive(PrimitiveBase):
    """Release a previously held button."""

    primitive: Literal["release"] = "release"
    button: Button


class WaitTurnPrimitive(PrimitiveBase):
    """Advance the dungeon turn without moving (A+B combo)."""

    primitive: Literal["wait_turn"] = "wait_turn"


class CapturePrimitive(PrimitiveBase):
    """Capture the current framebuffer and attach it to the trajectory."""

    primitive: Literal["capture"] = "capture"
    label: str = Field(..., min_length=1, max_length=64)


class RefreshStatePrimitive(PrimitiveBase):
    """Request a semantic state refresh from the runtime."""

    primitive: Literal["refresh_state"] = "refresh_state"
    fields: Optional[List[str]] = Field(
        default=None,
        description="Optional subset of state keys to refresh; defaults to entire snapshot.",
    )


class ExpectPrimitive(PrimitiveBase):
    """Assertion hook using semantic state expressions."""

    primitive: Literal["expect"] = "expect"
    expectation: str = Field(..., min_length=1, max_length=256)
    severity: Literal["warn", "fail"] = "fail"


class AnnotatePrimitive(PrimitiveBase):
    """Append a textual note to the trajectory for later LM judgement."""

    primitive: Literal["annotate"] = "annotate"
    message: str = Field(..., min_length=1, max_length=280)


class BreakPrimitive(PrimitiveBase):
    """Break out of the current control block."""

    primitive: Literal["break"] = "break"


class AbortPrimitive(PrimitiveBase):
    """Abort skill execution with a reason."""

    primitive: Literal["abort"] = "abort"
    reason: str = Field(..., min_length=1, max_length=200)


class SuccessPrimitive(PrimitiveBase):
    """Mark skill as successful and stop execution."""

    primitive: Literal["success"] = "success"
    summary: str = Field(default="success", min_length=1, max_length=160)


class CallPrimitive(PrimitiveBase):
    """Invoke another skill by name."""

    primitive: Literal["call"] = "call"
    skill: str = Field(..., min_length=1, max_length=64)
    params: Dict[str, Any] = Field(default_factory=dict)



class CheckpointPrimitive(PrimitiveBase):
    """Create a named checkpoint of the current execution state.
    
    Can be resumed later to restart from this point, enabling
    robust error recovery and multi-attempt strategies.
    """

    primitive: Literal["checkpoint"] = "checkpoint"
    label: str = Field(..., min_length=1, max_length=64)
    description: Optional[str] = Field(
        default=None, max_length=200,
        description="Optional description of what was accomplished before checkpoint"
    )


class ResumePrimitive(PrimitiveBase):
    """Resume execution from a previously created checkpoint.
    
    Restores the game state and execution context to allow recovery
    from transient failures or trying alternative approaches.
    """

    primitive: Literal["resume"] = "resume"
    label: str = Field(..., min_length=1, max_length=64)
    fallback_steps: Optional[List["Step"]] = Field(
        default=None,
        description="Steps to execute if checkpoint not found (optional)"
    )


class SaveStateCheckpointPrimitive(PrimitiveBase):
    """Save the current game state to a named save slot.
    
    Uses the SaveManager to persist state, allowing recovery after crashes
    or rollback to known-good game states.
    """

    primitive: Literal["save_checkpoint"] = "save_checkpoint"
    slot: int = Field(..., ge=0, le=15)
    label: str = Field(..., min_length=1, max_length=64)


class LoadStateCheckpointPrimitive(PrimitiveBase):
    """Load a previously saved game state from a save slot.
    
    Restores the dungeon to a known-good state, useful for recovery
    or trying alternative strategies after failed attempts.
    """

    primitive: Literal["load_checkpoint"] = "load_checkpoint"
    slot: int = Field(..., ge=0, le=15)


class InferenceCheckpointPrimitive(PrimitiveBase):
    """Pause skill execution and query the model for next steps.
    
    Enables mid-skill decision points where the LM can:
    - Observe current game state (screenshot + semantic state)
    - Decide whether to continue, abort, or change direction
    - Return additional primitive steps to execute next
    
    This is critical for adaptive agent behavior and recovery from
    unexpected situations that the skill didn't anticipate.
    """

    primitive: Literal["inference_checkpoint"] = "inference_checkpoint"
    label: str = Field(..., min_length=1, max_length=64)
    context: str = Field(
        ..., 
        min_length=1,
        max_length=500,
        description="Context about what the skill is trying to accomplish and why this checkpoint exists"
    )
    timeout_seconds: int = Field(
        default=30, ge=5, le=300,
        description="Max time to wait for model response"
    )



class ResumePrimitive(PrimitiveBase):
    """Resume execution from a previously created checkpoint.
    
    Restores the game state and execution context to allow recovery
    from transient failures or trying alternative approaches.
    """

    primitive: Literal["resume"] = "resume"
    label: str = Field(..., min_length=1, max_length=64)
    fallback_steps: Optional[List["Step"]] = Field(
        default=None,
        description="Steps to execute if checkpoint not found (optional)"
    )


class SaveStateCheckpointPrimitive(PrimitiveBase):
    """Save the current game state to a named save slot.
    
    Uses the SaveManager to persist state, allowing recovery after crashes
    or rollback to known-good game states.
    """

    primitive: Literal["save_checkpoint"] = "save_checkpoint"
    slot: int = Field(..., ge=0, le=15)
    label: str = Field(..., min_length=1, max_length=64)


class LoadStateCheckpointPrimitive(PrimitiveBase):
    """Load a previously saved game state from a save slot.
    
    Restores the dungeon to a known-good state, useful for recovery
    or trying alternative strategies after failed attempts.
    """

    primitive: Literal["load_checkpoint"] = "load_checkpoint"
    slot: int = Field(..., ge=0, le=15)


class InferenceCheckpointPrimitive(PrimitiveBase):
    """Pause skill execution and query the model for next steps.
    
    Enables mid-skill decision points where the LM can:
    - Observe current game state (screenshot + semantic state)
    - Decide whether to continue, abort, or change direction
    - Return additional primitive steps to execute next
    
    This is critical for adaptive agent behavior and recovery from
    unexpected situations that the skill didn't anticipate.
    """

    primitive: Literal["inference_checkpoint"] = "inference_checkpoint"
    label: str = Field(..., min_length=1, max_length=64)
    context: str = Field(
        ..., 
        min_length=1,
        max_length=500,
        description="Context about what the skill is trying to accomplish and why this checkpoint exists"
    )
    timeout_seconds: int = Field(
        default=30, ge=5, le=300,
        description="Max time to wait for model response"
    )


Primitive = Union[
    TapPrimitive,
    HoldPrimitive,
    ReleasePrimitive,
    WaitTurnPrimitive,
    CapturePrimitive,
    RefreshStatePrimitive,
    ExpectPrimitive,
    AnnotatePrimitive,
    BreakPrimitive,
    AbortPrimitive,
    SuccessPrimitive,
    CallPrimitive,
    CheckpointPrimitive,
    ResumePrimitive,
    SaveStateCheckpointPrimitive,
    LoadStateCheckpointPrimitive,
    InferenceCheckpointPrimitive,
]    CheckpointPrimitive,
    ResumePrimitive,
    SaveStateCheckpointPrimitive,
    LoadStateCheckpointPrimitive,
    InferenceCheckpointPrimitive,
]]


# ---------------------------------------------------------------------------
# Control blocks
# ---------------------------------------------------------------------------


class IfBlock(BaseModel):
    """Conditional execution block."""

    condition: str = Field(..., min_length=1, max_length=160)
    then: List["Step"] = Field(default_factory=list)
    otherwise: Optional[List["Step"]] = Field(default=None)

    class Config:
        extra = "forbid"
        allow_mutation = False


class WhileBlock(BaseModel):
    """Loop while a condition remains true."""

    condition: str = Field(..., min_length=1, max_length=160)
    body: List["Step"] = Field(default_factory=list)
    max_iterations: int = Field(default=24, ge=1, le=200)

    class Config:
        extra = "forbid"
        allow_mutation = False


# Step is either a primitive or a control block.
Step = Union[Primitive, IfBlock, WhileBlock]


# ---------------------------------------------------------------------------
# Skill metadata + spec
# ---------------------------------------------------------------------------


class SkillMeta(BaseModel):
    """Metadata attached to each skill."""

    name: str = Field(..., min_length=1, max_length=64)
    description: str = Field(..., min_length=1, max_length=400)
    version: str = Field(default="v1")
    tags: List[str] = Field(default_factory=list)
    expects: List[str] = Field(
        default_factory=list, description="Expected post-conditions for the skill."
    )
    partial_success_notes: List[str] = Field(
        default_factory=list,
        description="Common near-miss narratives that the LM can leverage for self-critique.",
    )

    class Config:
        extra = "forbid"
        allow_mutation = False


class SkillSpec(BaseModel):
    """Full skill specification."""

    meta: SkillMeta
    parameters: Dict[str, Any] = Field(default_factory=dict)
    steps: List[Step] = Field(default_factory=list)

    class Config:
        extra = "forbid"
        allow_mutation = False

    @validator("steps")
    def validate_steps(cls, steps: List[Step]) -> List[Step]:
        if not steps:
            raise ValueError("Skill requires at least one step")
        return steps

    def referenced_skills(self) -> List[str]:
        """Collect nested skill calls for dependency tracking."""
        calls: List[str] = []

        def _crawl(items: List[Step]):
            for node in items:
                if isinstance(node, CallPrimitive):
                    calls.append(node.skill)
                elif isinstance(node, IfBlock):
                    _crawl(node.then)
                    if node.otherwise:
                        _crawl(node.otherwise)
                elif isinstance(node, WhileBlock):
                    _crawl(node.body)

        _crawl(self.steps)
        return calls


# Useful alias for schema export when guiding LM output.
SKILL_SCHEMA = SkillSpec.schema()


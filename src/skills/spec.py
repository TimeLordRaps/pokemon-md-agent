"""Python-first skill specification models for the PMD agent.

The old YAML DSL is still available for backwards compatibility, but new skills
are authored as constrained Python objects that are intended to be generated by
structured LM output.  The schema is deliberately small so that we can produce
JSON (or Python) objects via grammar-guided decoding, resulting in far less
syntax drift compared to handwritten code.

Each primitive maps 1:1 to an environment capability (button press, semantic
state refresh, checkpointing, etc.).  Higher-level constructs compose these
primitives via simple control blocks (loops, conditionals, guarded execution).
"""

from __future__ import annotations

from enum import Enum
from typing import List, Optional, Union, Literal, Dict, Any

from pydantic import BaseModel, Field, validator


# ---------------------------------------------------------------------------
# Primitives
# ---------------------------------------------------------------------------


class Button(str, Enum):
    """Available GBA button presses supported by the harness."""

    A = "A"
    B = "B"
    L = "L"
    R = "R"
    START = "START"
    SELECT = "SELECT"
    UP = "UP"
    DOWN = "DOWN"
    LEFT = "LEFT"
    RIGHT = "RIGHT"
    A_B = "A+B"  # combined wait turn helper


class PrimitiveBase(BaseModel):
    """Base class for all primitives."""

    primitive: str

    class Config:
        extra = "forbid"
        allow_mutation = False
        validate_assignment = True


class TapPrimitive(PrimitiveBase):
    """Single frame button press."""

    primitive: Literal["tap"] = "tap"
    button: Button
    repeat: int = Field(default=1, ge=1, le=10, description="Times to tap")


class HoldPrimitive(PrimitiveBase):
    """Hold a button for a fixed number of frames."""

    primitive: Literal["hold"] = "hold"
    button: Button
    frames: int = Field(default=5, ge=1, le=60)


class ReleasePrimitive(PrimitiveBase):
    """Release a previously held button."""

    primitive: Literal["release"] = "release"
    button: Button


class WaitTurnPrimitive(PrimitiveBase):
    """Advance the dungeon turn without moving (A+B combo)."""

    primitive: Literal["wait_turn"] = "wait_turn"


class CapturePrimitive(PrimitiveBase):
    """Capture the current framebuffer and attach it to the trajectory."""

    primitive: Literal["capture"] = "capture"
    label: str = Field(..., min_length=1, max_length=64)


class RefreshStatePrimitive(PrimitiveBase):
    """Request a semantic state refresh from the runtime."""

    primitive: Literal["refresh_state"] = "refresh_state"
    fields: Optional[List[str]] = Field(
        default=None,
        description="Optional subset of state keys to refresh; defaults to entire snapshot.",
    )


class ExpectPrimitive(PrimitiveBase):
    """Assertion hook using semantic state expressions."""

    primitive: Literal["expect"] = "expect"
    expectation: str = Field(..., min_length=1, max_length=256)
    severity: Literal["warn", "fail"] = "fail"


class AnnotatePrimitive(PrimitiveBase):
    """Append a textual note to the trajectory for later LM judgement."""

    primitive: Literal["annotate"] = "annotate"
    message: str = Field(..., min_length=1, max_length=280)


class BreakPrimitive(PrimitiveBase):
    """Break out of the current control block."""

    primitive: Literal["break"] = "break"


class AbortPrimitive(PrimitiveBase):
    """Abort skill execution with a reason."""

    primitive: Literal["abort"] = "abort"
    reason: str = Field(..., min_length=1, max_length=200)


class SuccessPrimitive(PrimitiveBase):
    """Mark skill as successful and stop execution."""

    primitive: Literal["success"] = "success"
    summary: str = Field(default="success", min_length=1, max_length=160)


class CallPrimitive(PrimitiveBase):
    """Invoke another skill by name."""

    primitive: Literal["call"] = "call"
    skill: str = Field(..., min_length=1, max_length=64)
    params: Dict[str, Any] = Field(default_factory=dict)


Primitive = Union[
    TapPrimitive,
    HoldPrimitive,
    ReleasePrimitive,
    WaitTurnPrimitive,
    CapturePrimitive,
    RefreshStatePrimitive,
    ExpectPrimitive,
    AnnotatePrimitive,
    BreakPrimitive,
    AbortPrimitive,
    SuccessPrimitive,
    CallPrimitive,
]


# ---------------------------------------------------------------------------
# Control blocks
# ---------------------------------------------------------------------------


class IfBlock(BaseModel):
    """Conditional execution block."""

    condition: str = Field(..., min_length=1, max_length=160)
    then: List["Step"] = Field(default_factory=list)
    otherwise: Optional[List["Step"]] = Field(default=None)

    class Config:
        extra = "forbid"
        allow_mutation = False


class WhileBlock(BaseModel):
    """Loop while a condition remains true."""

    condition: str = Field(..., min_length=1, max_length=160)
    body: List["Step"] = Field(default_factory=list)
    max_iterations: int = Field(default=24, ge=1, le=200)

    class Config:
        extra = "forbid"
        allow_mutation = False


# Step is either a primitive or a control block.
Step = Union[Primitive, IfBlock, WhileBlock]


# ---------------------------------------------------------------------------
# Skill metadata + spec
# ---------------------------------------------------------------------------


class SkillMeta(BaseModel):
    """Metadata attached to each skill."""

    name: str = Field(..., min_length=1, max_length=64)
    description: str = Field(..., min_length=1, max_length=400)
    version: str = Field(default="v1")
    tags: List[str] = Field(default_factory=list)
    expects: List[str] = Field(
        default_factory=list, description="Expected post-conditions for the skill."
    )
    partial_success_notes: List[str] = Field(
        default_factory=list,
        description="Common near-miss narratives that the LM can leverage for self-critique.",
    )

    class Config:
        extra = "forbid"
        allow_mutation = False


class SkillSpec(BaseModel):
    """Full skill specification."""

    meta: SkillMeta
    parameters: Dict[str, Any] = Field(default_factory=dict)
    steps: List[Step] = Field(default_factory=list)

    class Config:
        extra = "forbid"
        allow_mutation = False

    @validator("steps")
    def validate_steps(cls, steps: List[Step]) -> List[Step]:
        if not steps:
            raise ValueError("Skill requires at least one step")
        return steps

    def referenced_skills(self) -> List[str]:
        """Collect nested skill calls for dependency tracking."""
        calls: List[str] = []

        def _crawl(items: List[Step]):
            for node in items:
                if isinstance(node, CallPrimitive):
                    calls.append(node.skill)
                elif isinstance(node, IfBlock):
                    _crawl(node.then)
                    if node.otherwise:
                        _crawl(node.otherwise)
                elif isinstance(node, WhileBlock):
                    _crawl(node.body)

        _crawl(self.steps)
        return calls


# Useful alias for schema export when guiding LM output.
SKILL_SCHEMA = SkillSpec.schema()

